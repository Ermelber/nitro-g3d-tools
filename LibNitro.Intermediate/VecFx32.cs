using System;
using LibFoundation.Math;

namespace LibNitro.Intermediate
{
    public static class Fx32
    {
        public static int FromFloat(float value) => (int) Math.Round(value * 4096);
        public static float ToFloat(int value) => value / 4096f;
    }

    public struct VecFx32
    {
        public int X;
        public int Y;
        public int Z;

        public VecFx32(int x, int y, int z)
        {
            X = x;
            Y = y;
            Z = z;
        }

        public VecFx32(int value)
        {
            X = value;
            Y = value;
            Z = value;
        }

        public VecFx32(float x, float y, float z)
        {
            X = Fx32.FromFloat(x);
            Y = Fx32.FromFloat(y);
            Z = Fx32.FromFloat(z);
        }

        public VecFx32(float value)
        {
            X = Fx32.FromFloat(value);
            Y = Fx32.FromFloat(value);
            Z = Fx32.FromFloat(value);
        }

        public VecFx32(Vector3 vec)
        {
            X = Fx32.FromFloat(vec.X);
            Y = Fx32.FromFloat(vec.Y);
            Z = Fx32.FromFloat(vec.Z);
        }

        public (int, int, int) ToIntegers()
        {
            return (X, Y, Z);
        }

        public Vector3 ToVector3()
        {
            return (Fx32.ToFloat(X), Fx32.ToFloat(Y), Fx32.ToFloat(Z));
        }

        public static VecFx32 operator >>(VecFx32 vec, int shift) =>
            new VecFx32(vec.X >> shift, vec.Y >> shift, vec.Z >> shift);

        public static VecFx32 operator -(VecFx32 vec1, VecFx32 vec2) =>
            new VecFx32(vec1.X - vec2.X, vec1.Y - vec2.Y, vec1.Z - vec2.Z);

        public static VecFx32 operator +(VecFx32 vec1, VecFx32 vec2) =>
            new VecFx32(vec1.X + vec2.X, vec1.Y + vec2.Y, vec1.Z + vec2.Z);

        public static VecFx32 operator *(VecFx32 vec1, int value) =>
            new VecFx32(vec1.X * value, vec1.Y * value, vec1.Z * value);

        public static VecFx32 operator *(VecFx32 vec1, float value) =>
            new VecFx32(Fx32.ToFloat(vec1.X) * value, Fx32.ToFloat(vec1.Y) * value, Fx32.ToFloat(vec1.Z) * value);

        public static bool operator ==(VecFx32 vec1, VecFx32 vec2) => vec1.Equals(vec2);

        public static bool operator !=(VecFx32 vec1, VecFx32 vec2) => !(vec1 == vec2);

        //Autogenerated
        public bool Equals(VecFx32 other)
        {
            return X == other.X && Y == other.Y && Z == other.Z;
        }

        public override bool Equals(object obj)
        {
            return obj is VecFx32 other && Equals(other);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                var hashCode = X;
                hashCode = (hashCode * 397) ^ Y;
                hashCode = (hashCode * 397) ^ Z;
                return hashCode;
            }
        }

    }
}